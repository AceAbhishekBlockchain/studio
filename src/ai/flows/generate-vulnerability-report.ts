
'use server';
/**
 * @fileOverview This file defines a Genkit flow that generates a vulnerability report for smart contract code
 * based on the code itself and a list of selected analysis tools.
 *
 * - generateVulnerabilityReport - A function that takes smart contract code and selected tools,
 *   and returns a list of potential vulnerabilities.
 * - GenerateVulnerabilityReportInput - The input type for the function.
 * - GenerateVulnerabilityReportOutput - The return type for the function.
 * - Vulnerability - The type definition for a single vulnerability.
 */

import { initializeGenkit } from '@/ai/genkit';
import {z} from 'genkit';

const VulnerabilitySchema = z.object({
  id: z.string().describe('A unique identifier for the vulnerability (e.g., vuln-001).'),
  title: z.string().describe('A concise title for the vulnerability.'),
  severity: z.enum(['Critical', 'High', 'Medium', 'Low', 'Informational']).describe('The severity level of the vulnerability.'),
  description: z.string().describe('A detailed description of the potential vulnerability, including affected code parts if possible.'),
  tool: z.string().describe('The name of the analysis tool (from the provided selected list) that would most likely detect this vulnerability.'),
});
export type Vulnerability = z.infer<typeof VulnerabilitySchema>;

const GenerateVulnerabilityReportInputSchema = z.object({
  smartContractCode: z.string().describe('The smart contract code to be analyzed.'),
  selectedTools: z.array(z.string()).describe('A list of names of the analysis tools selected for use.'),
});
export type GenerateVulnerabilityReportInput = z.infer<typeof GenerateVulnerabilityReportInputSchema>;

const GenerateVulnerabilityReportOutputSchema = z.object({
  vulnerabilities: z.array(VulnerabilitySchema).describe('A list of potential vulnerabilities identified in the smart contract code.'),
});
export type GenerateVulnerabilityReportOutput = z.infer<typeof GenerateVulnerabilityReportOutputSchema>;

export async function generateVulnerabilityReport(input: GenerateVulnerabilityReportInput): Promise<GenerateVulnerabilityReportOutput> {
  return generateVulnerabilityReportFlow(input);
}

const genkit = await initializeGenkit();

const prompt = genkit.definePrompt({
  name: 'generateVulnerabilityReportPrompt',
  input: {
    schema: GenerateVulnerabilityReportInputSchema,
  },
  output: {
    schema: GenerateVulnerabilityReportOutputSchema,
  },
  prompt: `You are a smart contract security expert. Analyze the provided smart contract code.
Based on the code and the list of selected analysis tools, identify potential vulnerabilities.
For each vulnerability:
- Provide a unique ID (e.g., vuln-001, vuln-002).
- Write a clear title.
- Assign a severity level: Critical, High, Medium, Low, or Informational.
- Describe the vulnerability in detail, mentioning specific code parts if relevant.
- Indicate which of the *selected* analysis tools would likely report this vulnerability.

Smart Contract Code:
\`\`\`
{{{smartContractCode}}}
\`\`\`

Selected Analysis Tools:
{{#each selectedTools}}
- {{{this}}}
{{/each}}

Return your findings as a JSON object with a "vulnerabilities" field, containing an array of vulnerability objects as per the defined schema.
If no vulnerabilities are found by the selected tools, return an empty "vulnerabilities" array.
`,
});

const generateVulnerabilityReportFlow = genkit.defineFlow(
  {
    name: 'generateVulnerabilityReportFlow',
    inputSchema: GenerateVulnerabilityReportInputSchema,
    outputSchema: GenerateVulnerabilityReportOutputSchema,
  },
  async input => {
    // Defensive check: If no tools are selected, perhaps return empty vulnerabilities.
    // However, the prompt should handle this by being told which tools are selected.
    // If selectedTools is empty, the LLM might not generate relevant vulnerabilities.
    if (input.selectedTools.length === 0) {
      return { vulnerabilities: [] };
    }

    const {output} = await prompt(input);
    // Ensure IDs are somewhat unique if LLM doesn't make them perfectly unique, or add prefix.
    // For now, trust the LLM based on schema description.
    return output!;
  }
);
